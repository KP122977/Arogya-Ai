import os
import joblib
import numpy as np
import pandas as pd
from django.conf import settings
from rest_framework.decorators import api_view
from rest_framework.views import APIView
from rest_framework.parsers import MultiPartParser
from sklearn.ensemble import RandomForestClassifier, RandomForestRegressor
from sklearn.model_selection import train_test_split
from rest_framework.response import Response
from rest_framework import status
import google.generativeai as genai
from dotenv import load_dotenv
import logging

# Load environment variables
load_dotenv()

# Configure logging
logger = logging.getLogger(__name__)

# Configure Gemini API key securely
GEMINI_API_KEY = os.getenv("GEMINI_API_KEY")
if not GEMINI_API_KEY:
    raise ValueError("GEMINI_API_KEY is not set in environment variables.")
genai.configure(api_key=GEMINI_API_KEY)

# Load model data
BASE_DIR = settings.BASE_DIR
model_data = joblib.load(os.path.join(BASE_DIR, "model", "disease_model.pkl"))
model_data = joblib.load("model/disease_model.pkl")
model = model_data["model"]
label_encoder = model_data["label_encoder"]
feature_names = model_data["feature_names"]

# Embed symptom list directly (based on your latest CSV training data)
symptom_list = [
     'Fever', 'Fatigue', 'Sweating', 'Chills', 'Weight_Loss', 'Weight_Gain',
    'Cough', 'Runny_Nose', 'Sore_Throat', 'Shortness_of_Breath', 'Chest_Congestion',
    'Nausea', 'Vomiting', 'Diarrhea', 'Abdominal_Pain', 'Loss_of_Appetite',
    'Headache', 'Dizziness', 'Sleep_Disturbance', 'Rash', 'Itching', 'Redness',
    'Swelling', 'Joint_Pain', 'Muscle_Pain', 'Back_Pain', 'Frequent_Urination',
    'Increased_Thirst', 'Dry_Mouth', 'Sneezing'
]

@api_view(["POST"])
def predict_disease(request):
    try:
        selected_symptoms = request.data.get("symptoms", [])
        if not selected_symptoms:
            return Response({"error": "No symptoms provided"}, status=status.HTTP_400_BAD_REQUEST)

       # Create binary input DataFrame with proper feature names
        input_data = [1 if symptom in selected_symptoms else 0 for symptom in feature_names]
        input_df = pd.DataFrame([input_data], columns=feature_names)


        # Make prediction
        prediction = model.predict(input_df)[0]
        confidence_scores = model.predict_proba(input_df)[0]
        confidence = float(np.max(confidence_scores)) * 100

        predicted_disease = label_encoder.inverse_transform([prediction])[0]

        return Response({
            "prediction": predicted_disease,
            "confidence": f"{confidence:.2f}%"
        })

    except Exception as e:
        print(f"Prediction error: {e}")
        return Response({"error": "An error occurred during prediction."}, status=500)

@api_view(["POST"])
def prescribe_disease(request):
    try:
        data = request.data
        disease = data.get("disease", "").strip()

        if not disease:
            return Response({"error": "Disease name not provided"}, status=400)

        prompt = f"""
You are a professional doctor.

Write a SHORT prescription for the disease: {disease}

⚠️ STRICT INSTRUCTIONS:
- MAX 4 lines total
- DO NOT write any explanations, disclaimers, or introductions
- DO NOT include headings like “Rx”, “Instructions”, “Diagnosis”, etc.
- Only list medicines, dosage, timing, duration, and short advice
- Advice MUST be 1-2 short sentences only
- OUTPUT must look like a real doctor's prescription note, nothing else

FORMAT STRICTLY:
- Medicine 1 – <Dosage>, <Timing>
- Medicine 2 – <Dosage>, <Timing>
- Duration: X days
- Advice: <short 1-2 lines only>
"""
        model = genai.GenerativeModel(
            "gemini-2.5-flash",
            system_instruction="Respond ONLY with a 4-line prescription in the format of a professional doctor. DO NOT provide explanations, context, or disclaimers under any circumstances."
        )
        response = model.generate_content(prompt)

        if not hasattr(response, "text") or not response.text:
            return Response({"error": "No content generated by Gemini."}, status=500)

        raw_output = response.text.strip()
        trimmed_output = "\n".join(raw_output.splitlines()[:5])

        return Response({"prescription": trimmed_output})

    except Exception as e:
        logger.error("Gemini API error: %s", e)
        return Response(
            {"error": "Failed to generate prescription. Please try again later."},
            status=status.HTTP_500_INTERNAL_SERVER_ERROR
        )


class HeartHealthAnalyzer(APIView): 
    parser_classes = [MultiPartParser]

    def post(self, request):
        file = request.data.get("file")
        if not file:
            return Response({"error": "No file uploaded"}, status=400)

        try:
            # Try reading the CSV
            df = pd.read_csv(file, encoding="utf-8-sig")
            df.columns = df.columns.str.strip().str.lower()

            if 'target' not in df.columns:
                return Response({
                    "error": "CSV must include a 'target' column (0 or 1).",
                    "columns_found": list(df.columns)
                }, status=400)

            # Convert to numeric and drop NaNs
            df = df.apply(pd.to_numeric, errors='coerce')
            df = df.dropna()
            if df.empty:
                return Response({"error": "No valid data after cleaning."}, status=400)

            # Prepare training data
            X_train = df.drop(columns=['target'])
            y_train = df['target']

            # Train classifiers
            clf = RandomForestClassifier()
            reg = RandomForestRegressor()
            clf.fit(X_train, y_train)

            avg_input = X_train.mean().to_frame().T  # shape: (1, n_features)

            disease_pred = clf.predict(avg_input)[0]
            blockage_pred = reg.fit(
                X_train,
                np.where(
                    y_train == 1,
                    np.random.randint(40, 90, size=len(y_train)),
                    np.random.randint(10, 30, size=len(y_train))
                )
            ).predict(avg_input)[0]

            health_score = 100 - (blockage_pred * (1.2 if disease_pred == 1 else 0.6))

            avg_features = avg_input.iloc[0].to_dict()

            return Response({
                "heart_disease": int(disease_pred),
                "blockage_percent": round(blockage_pred, 2),
                "heart_health_score": round(health_score, 2),
                "average_features": {
                    "thalach": round(avg_features.get("thalach", 0), 2),
                    "trestbps": round(avg_features.get("trestbps", 0), 2),
                    "chol": round(avg_features.get("chol", 0), 2),
                }
            })

        except Exception as e:
            return Response({"error": f"Internal error: {str(e)}"}, status=500)
